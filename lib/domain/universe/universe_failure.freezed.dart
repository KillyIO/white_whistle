// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'universe_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$UniverseFailureTearOff {
  const _$UniverseFailureTearOff();

  UniverseNotCreated universeNotCreated() {
    return const UniverseNotCreated();
  }

  UniverseNotDeleted universeNotDeleted() {
    return const UniverseNotDeleted();
  }

  UniverseNotFound universeNotFound() {
    return const UniverseNotFound();
  }

  UniverseNotUpdated universeNotUpdated() {
    return const UniverseNotUpdated();
  }
}

/// @nodoc
const $UniverseFailure = _$UniverseFailureTearOff();

/// @nodoc
mixin _$UniverseFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() universeNotCreated,
    required TResult Function() universeNotDeleted,
    required TResult Function() universeNotFound,
    required TResult Function() universeNotUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? universeNotCreated,
    TResult Function()? universeNotDeleted,
    TResult Function()? universeNotFound,
    TResult Function()? universeNotUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? universeNotCreated,
    TResult Function()? universeNotDeleted,
    TResult Function()? universeNotFound,
    TResult Function()? universeNotUpdated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UniverseNotCreated value) universeNotCreated,
    required TResult Function(UniverseNotDeleted value) universeNotDeleted,
    required TResult Function(UniverseNotFound value) universeNotFound,
    required TResult Function(UniverseNotUpdated value) universeNotUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UniverseNotCreated value)? universeNotCreated,
    TResult Function(UniverseNotDeleted value)? universeNotDeleted,
    TResult Function(UniverseNotFound value)? universeNotFound,
    TResult Function(UniverseNotUpdated value)? universeNotUpdated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UniverseNotCreated value)? universeNotCreated,
    TResult Function(UniverseNotDeleted value)? universeNotDeleted,
    TResult Function(UniverseNotFound value)? universeNotFound,
    TResult Function(UniverseNotUpdated value)? universeNotUpdated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UniverseFailureCopyWith<$Res> {
  factory $UniverseFailureCopyWith(
          UniverseFailure value, $Res Function(UniverseFailure) then) =
      _$UniverseFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$UniverseFailureCopyWithImpl<$Res>
    implements $UniverseFailureCopyWith<$Res> {
  _$UniverseFailureCopyWithImpl(this._value, this._then);

  final UniverseFailure _value;
  // ignore: unused_field
  final $Res Function(UniverseFailure) _then;
}

/// @nodoc
abstract class $UniverseNotCreatedCopyWith<$Res> {
  factory $UniverseNotCreatedCopyWith(
          UniverseNotCreated value, $Res Function(UniverseNotCreated) then) =
      _$UniverseNotCreatedCopyWithImpl<$Res>;
}

/// @nodoc
class _$UniverseNotCreatedCopyWithImpl<$Res>
    extends _$UniverseFailureCopyWithImpl<$Res>
    implements $UniverseNotCreatedCopyWith<$Res> {
  _$UniverseNotCreatedCopyWithImpl(
      UniverseNotCreated _value, $Res Function(UniverseNotCreated) _then)
      : super(_value, (v) => _then(v as UniverseNotCreated));

  @override
  UniverseNotCreated get _value => super._value as UniverseNotCreated;
}

/// @nodoc

class _$UniverseNotCreated implements UniverseNotCreated {
  const _$UniverseNotCreated();

  @override
  String toString() {
    return 'UniverseFailure.universeNotCreated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UniverseNotCreated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() universeNotCreated,
    required TResult Function() universeNotDeleted,
    required TResult Function() universeNotFound,
    required TResult Function() universeNotUpdated,
  }) {
    return universeNotCreated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? universeNotCreated,
    TResult Function()? universeNotDeleted,
    TResult Function()? universeNotFound,
    TResult Function()? universeNotUpdated,
  }) {
    return universeNotCreated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? universeNotCreated,
    TResult Function()? universeNotDeleted,
    TResult Function()? universeNotFound,
    TResult Function()? universeNotUpdated,
    required TResult orElse(),
  }) {
    if (universeNotCreated != null) {
      return universeNotCreated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UniverseNotCreated value) universeNotCreated,
    required TResult Function(UniverseNotDeleted value) universeNotDeleted,
    required TResult Function(UniverseNotFound value) universeNotFound,
    required TResult Function(UniverseNotUpdated value) universeNotUpdated,
  }) {
    return universeNotCreated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UniverseNotCreated value)? universeNotCreated,
    TResult Function(UniverseNotDeleted value)? universeNotDeleted,
    TResult Function(UniverseNotFound value)? universeNotFound,
    TResult Function(UniverseNotUpdated value)? universeNotUpdated,
  }) {
    return universeNotCreated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UniverseNotCreated value)? universeNotCreated,
    TResult Function(UniverseNotDeleted value)? universeNotDeleted,
    TResult Function(UniverseNotFound value)? universeNotFound,
    TResult Function(UniverseNotUpdated value)? universeNotUpdated,
    required TResult orElse(),
  }) {
    if (universeNotCreated != null) {
      return universeNotCreated(this);
    }
    return orElse();
  }
}

abstract class UniverseNotCreated implements UniverseFailure {
  const factory UniverseNotCreated() = _$UniverseNotCreated;
}

/// @nodoc
abstract class $UniverseNotDeletedCopyWith<$Res> {
  factory $UniverseNotDeletedCopyWith(
          UniverseNotDeleted value, $Res Function(UniverseNotDeleted) then) =
      _$UniverseNotDeletedCopyWithImpl<$Res>;
}

/// @nodoc
class _$UniverseNotDeletedCopyWithImpl<$Res>
    extends _$UniverseFailureCopyWithImpl<$Res>
    implements $UniverseNotDeletedCopyWith<$Res> {
  _$UniverseNotDeletedCopyWithImpl(
      UniverseNotDeleted _value, $Res Function(UniverseNotDeleted) _then)
      : super(_value, (v) => _then(v as UniverseNotDeleted));

  @override
  UniverseNotDeleted get _value => super._value as UniverseNotDeleted;
}

/// @nodoc

class _$UniverseNotDeleted implements UniverseNotDeleted {
  const _$UniverseNotDeleted();

  @override
  String toString() {
    return 'UniverseFailure.universeNotDeleted()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UniverseNotDeleted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() universeNotCreated,
    required TResult Function() universeNotDeleted,
    required TResult Function() universeNotFound,
    required TResult Function() universeNotUpdated,
  }) {
    return universeNotDeleted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? universeNotCreated,
    TResult Function()? universeNotDeleted,
    TResult Function()? universeNotFound,
    TResult Function()? universeNotUpdated,
  }) {
    return universeNotDeleted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? universeNotCreated,
    TResult Function()? universeNotDeleted,
    TResult Function()? universeNotFound,
    TResult Function()? universeNotUpdated,
    required TResult orElse(),
  }) {
    if (universeNotDeleted != null) {
      return universeNotDeleted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UniverseNotCreated value) universeNotCreated,
    required TResult Function(UniverseNotDeleted value) universeNotDeleted,
    required TResult Function(UniverseNotFound value) universeNotFound,
    required TResult Function(UniverseNotUpdated value) universeNotUpdated,
  }) {
    return universeNotDeleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UniverseNotCreated value)? universeNotCreated,
    TResult Function(UniverseNotDeleted value)? universeNotDeleted,
    TResult Function(UniverseNotFound value)? universeNotFound,
    TResult Function(UniverseNotUpdated value)? universeNotUpdated,
  }) {
    return universeNotDeleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UniverseNotCreated value)? universeNotCreated,
    TResult Function(UniverseNotDeleted value)? universeNotDeleted,
    TResult Function(UniverseNotFound value)? universeNotFound,
    TResult Function(UniverseNotUpdated value)? universeNotUpdated,
    required TResult orElse(),
  }) {
    if (universeNotDeleted != null) {
      return universeNotDeleted(this);
    }
    return orElse();
  }
}

abstract class UniverseNotDeleted implements UniverseFailure {
  const factory UniverseNotDeleted() = _$UniverseNotDeleted;
}

/// @nodoc
abstract class $UniverseNotFoundCopyWith<$Res> {
  factory $UniverseNotFoundCopyWith(
          UniverseNotFound value, $Res Function(UniverseNotFound) then) =
      _$UniverseNotFoundCopyWithImpl<$Res>;
}

/// @nodoc
class _$UniverseNotFoundCopyWithImpl<$Res>
    extends _$UniverseFailureCopyWithImpl<$Res>
    implements $UniverseNotFoundCopyWith<$Res> {
  _$UniverseNotFoundCopyWithImpl(
      UniverseNotFound _value, $Res Function(UniverseNotFound) _then)
      : super(_value, (v) => _then(v as UniverseNotFound));

  @override
  UniverseNotFound get _value => super._value as UniverseNotFound;
}

/// @nodoc

class _$UniverseNotFound implements UniverseNotFound {
  const _$UniverseNotFound();

  @override
  String toString() {
    return 'UniverseFailure.universeNotFound()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UniverseNotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() universeNotCreated,
    required TResult Function() universeNotDeleted,
    required TResult Function() universeNotFound,
    required TResult Function() universeNotUpdated,
  }) {
    return universeNotFound();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? universeNotCreated,
    TResult Function()? universeNotDeleted,
    TResult Function()? universeNotFound,
    TResult Function()? universeNotUpdated,
  }) {
    return universeNotFound?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? universeNotCreated,
    TResult Function()? universeNotDeleted,
    TResult Function()? universeNotFound,
    TResult Function()? universeNotUpdated,
    required TResult orElse(),
  }) {
    if (universeNotFound != null) {
      return universeNotFound();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UniverseNotCreated value) universeNotCreated,
    required TResult Function(UniverseNotDeleted value) universeNotDeleted,
    required TResult Function(UniverseNotFound value) universeNotFound,
    required TResult Function(UniverseNotUpdated value) universeNotUpdated,
  }) {
    return universeNotFound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UniverseNotCreated value)? universeNotCreated,
    TResult Function(UniverseNotDeleted value)? universeNotDeleted,
    TResult Function(UniverseNotFound value)? universeNotFound,
    TResult Function(UniverseNotUpdated value)? universeNotUpdated,
  }) {
    return universeNotFound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UniverseNotCreated value)? universeNotCreated,
    TResult Function(UniverseNotDeleted value)? universeNotDeleted,
    TResult Function(UniverseNotFound value)? universeNotFound,
    TResult Function(UniverseNotUpdated value)? universeNotUpdated,
    required TResult orElse(),
  }) {
    if (universeNotFound != null) {
      return universeNotFound(this);
    }
    return orElse();
  }
}

abstract class UniverseNotFound implements UniverseFailure {
  const factory UniverseNotFound() = _$UniverseNotFound;
}

/// @nodoc
abstract class $UniverseNotUpdatedCopyWith<$Res> {
  factory $UniverseNotUpdatedCopyWith(
          UniverseNotUpdated value, $Res Function(UniverseNotUpdated) then) =
      _$UniverseNotUpdatedCopyWithImpl<$Res>;
}

/// @nodoc
class _$UniverseNotUpdatedCopyWithImpl<$Res>
    extends _$UniverseFailureCopyWithImpl<$Res>
    implements $UniverseNotUpdatedCopyWith<$Res> {
  _$UniverseNotUpdatedCopyWithImpl(
      UniverseNotUpdated _value, $Res Function(UniverseNotUpdated) _then)
      : super(_value, (v) => _then(v as UniverseNotUpdated));

  @override
  UniverseNotUpdated get _value => super._value as UniverseNotUpdated;
}

/// @nodoc

class _$UniverseNotUpdated implements UniverseNotUpdated {
  const _$UniverseNotUpdated();

  @override
  String toString() {
    return 'UniverseFailure.universeNotUpdated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UniverseNotUpdated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() universeNotCreated,
    required TResult Function() universeNotDeleted,
    required TResult Function() universeNotFound,
    required TResult Function() universeNotUpdated,
  }) {
    return universeNotUpdated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? universeNotCreated,
    TResult Function()? universeNotDeleted,
    TResult Function()? universeNotFound,
    TResult Function()? universeNotUpdated,
  }) {
    return universeNotUpdated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? universeNotCreated,
    TResult Function()? universeNotDeleted,
    TResult Function()? universeNotFound,
    TResult Function()? universeNotUpdated,
    required TResult orElse(),
  }) {
    if (universeNotUpdated != null) {
      return universeNotUpdated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UniverseNotCreated value) universeNotCreated,
    required TResult Function(UniverseNotDeleted value) universeNotDeleted,
    required TResult Function(UniverseNotFound value) universeNotFound,
    required TResult Function(UniverseNotUpdated value) universeNotUpdated,
  }) {
    return universeNotUpdated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UniverseNotCreated value)? universeNotCreated,
    TResult Function(UniverseNotDeleted value)? universeNotDeleted,
    TResult Function(UniverseNotFound value)? universeNotFound,
    TResult Function(UniverseNotUpdated value)? universeNotUpdated,
  }) {
    return universeNotUpdated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UniverseNotCreated value)? universeNotCreated,
    TResult Function(UniverseNotDeleted value)? universeNotDeleted,
    TResult Function(UniverseNotFound value)? universeNotFound,
    TResult Function(UniverseNotUpdated value)? universeNotUpdated,
    required TResult orElse(),
  }) {
    if (universeNotUpdated != null) {
      return universeNotUpdated(this);
    }
    return orElse();
  }
}

abstract class UniverseNotUpdated implements UniverseFailure {
  const factory UniverseNotUpdated() = _$UniverseNotUpdated;
}
